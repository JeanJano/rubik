Fase 1:

Ahora el objetivo primordial de usar simetrias es lograr dividir en clases de equivalencia el espacio de indices de la pruning table final
cada indice se deduce a partir de tres coordenadas, luego la idea es aplicar las simetrias al estado current del cubo y calcular las coordenadas resultantes bajo simetria.
para lo cual a cada coordenada debe podersele aplicar una simetria y obtener la coordenada resultante asi como su inversa: dada una coordenada sabe desde que 
coordenada llego despues de aplicarsele una simetria. pues en algun momento debere poder mostrar cual es el movimiento correcto dada la simetria desde la que se escogio 
el representante de la clase. 

Veamoslo asi, comienzo a escribir la pruning table, inicializo 0 0 0 como estado inicial, en una primera instancia, cualquier giro que contnega ' caera en la misma
clase de equivalencia que sera reducido, digamos a F', es decir que el movimiento F de cualquier cubo que termine con un giro antihorario va a tener F como movimiento final
asi pues se debera especificarse la simetria usada para poder aplicar el giro en la cara deseada, debera existir una funcion que dado un movimiento y una simetria
de como resultado el movimiento real del estado sin simetria la pregunta es que funciones deberan incluir el estado. que usa que?

Ahora pienso que al tomar el representante de cada clase es a el al que le aplicare los 18 movimientos para encontrar nuevas coordenadas de las cuales escogere su representante 
y le asignare una nueva deepth, es decir que es al momento de solucionar el cubo, cuando se lee la pruning table cuando se debe deducir la simetria bajo la que se hara el movimiento.
por ejemplo: Se toma el estado del scramble, se encuentra su representate de clase y se reserva la simetria bajo la cual se llego a ese representante ese representante tendra una
deepth, se haran los 18 movimientos sobre este cubo, encontrando sus 18 respectivos representantes de clase y mirando su deepth, cuando se encuentre la menor de estas,
se definira ese como el movimiento a seguir, se hara el movimiento correspondiente al estado sin la simetria original y ya veremos si podremos usar las simetrias compuestas para
deducir la simetria del nuevo estado con respecto al estado real (en ese momento ya no sera necesario buscar el represetante de clase pues lo obtuvimos ne el anterior paso)

Utiles necesarios:

PARA LEER PRUNING TABLE Y SOLUCIONAR

Principales

SolvefaseOne: => Toma un estado del cubo, encuentra su representante de clase
=> bucle
  decide el siguiente movimiento y lo aplica bajo simetria inversa
  deduce la simetria del cube raw resultante sobre el representante del nuevo
  estado 
  repite hasta llegar a depth 0

retorna los movimientos decididos sobre el cube raw


Secundarios
/*
  Cuestion a resolver: si se que bajo una simetria aplico el movimiento x a un estado
  que movimiento equivalente debera aplicarsele al cubo que existio antes de aplicar la simetria

  =>funcion MoveSymInv
*/
MoveSymInv(simetria aplicada, Movimiento_dentro simetria):
=> retorna movimiento Bajo simetria inversa

/*
  Cuestion a resolver: si aplico dos simetrias a un cubo cual es la mejor forma de gestionar los movimientos?
  si tengo represetantes de estado que podrian estar bajo cualquier simetria
  
  => tabla de simetrias compuestas
  => defincion e indexacion de 48 simetrias 
*/
      => definicion e indexacion de cada simetria sobre nivel cubie
=> Tabla simetrias compuestas



PARA ESCRIBIR PRUNING TABLE

/*
Cuestion a resolver: 

en la funcion pruningTableToFile, 
como elijo el represetante de una clase? y como guardo su profundidad?
creo que lo mejor sera mantener el archivo del mismo tamano aunqeu sea re pesado dada la
rapidez por busqueda de indice se debera usar una funcion que haye el representante de un
indice, a cada indice se le aplica esta funcion, el resto de la escritutra de la pruning table no cambia.
solo que la hacer alguno de los 18 movimientos se calculara el representante del estado resultante
asi si este ya estaba en lista se pasa de largo pero si no estaba se crea una heuristica nueva.

requerimientos:
=> funcion IndexRepresentant
*/

  /*
    cuestion a resolver: dado un indice como encuentro el representante de su clase?

    Usando el hecho de que en la funcion pruningTableToFile se tratan los estados en su forma
    coordenada habra que aplicar las 48 simetrias al estado, aplicandola a cada una de sus
    tres coordenadas para posteriormente hallar el indice del estado resultante y escoger
    el menor de estos indices

    => funcion MinIndex:
  */

    /*
    Cuestion a resolver: aplicar simetrias a cada una de las coordenadas:
    Se podria tomar la coordenada, encontrar su representacion como coordenada explicita
    aplicar la simetria en nivel cubie, y deducir la coordenada pura resultante, esto con
    las tres coordenadas lo cual al final permitira calcular un nuevo index entre las
    48 simetrias y escoger el menor de estos.

    para evitar hacer un calculo cada vez seria bueno usar symetry tables. serian 48 por
    cada una de las tres coordenadas de la fase one, tablas que tomarian cada uno de los
    estados posibles en cada coordenada y los mapearia en su estado resultante
    asi el proceso seria mas simple al simplemente usar tablas de simetrias para
    encontrar el index bajo la simetria buscada. De esta forma el calculo de la coordenada
    pura resultante bajo simetria se haria una sola vez por simetria

    => createSymetryTables()
    => funcion CornOriUnderSym(simetria, coordenada)
    => funcion EdgeOriUnderSym(simetria, coordenada)
    => funcion UDSliceUnderSym(simetria, coordenada)
    */


    createSymetryTables():
    por cada simetria posible
    recorre las coordenadas posibles (como coordenada pura) de cada 
    una de las tres coordenadas fase 1
    las lleva a su coordenada explicita,
    aplica la symetria current a nivel cubie,
    calcula la coordenada pura resultante
    por cada una de las 48 simetrias habra 3 tablas por cada coordenada

    funcion CornOriUnderSym(simetria, coordenada)
    funcion EdgeOriUnderSym(simetria, coordenada)
    funcion UDSliceUnderSym(simetria, coordenada)

    simplemente leeran la tabla de simetrias X con una coordenada Y y retornaran
    la coordenada pura correspondiente

/*